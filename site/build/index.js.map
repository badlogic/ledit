{
  "version": 3,
  "sources": ["../utils.ts", "../index.ts"],
  "sourcesContent": ["export interface Posts {\n  kind: \"listing\";\n  data: {\n    after: string;\n    children: Post[];\n  };\n}\n\nexport interface Post {\n  data: {\n    author: string;\n    created_utc: number;\n    domain: string;\n    is_created_from_ads_ui: boolean;\n    is_reddit_media_domain: boolean;\n    is_video: boolean;\n    is_self: boolean;\n    num_comments: number;\n    over_18: boolean;\n    permalink: string;\n    selftext_html: string;\n    preview: {\n      enabled: boolean;\n      images: {\n        resolutions: {\n          url: string;\n          width: number;\n          height: number;\n        }[];\n      }[];\n      reddit_video_preview: {\n        dash_url: string;\n        fallback_url: string;\n        is_gif: boolean;\n      } | null;\n      source: {\n        url: string;\n        width: number;\n        height: number;\n      };\n    };\n    secure_media_embed: {\n      content: string;\n      width: number;\n      height: number;\n      media_domain_url: string;\n    };\n    score: number;\n    subreddit: string;\n    thumbnail: string;\n    title: string;\n    ups: number;\n    downs: number;\n    url: string;\n  };\n}\n\nexport interface Comment {\n    data: {\n        author: string,\n        created_utc: number,\n        body_html: string,\n        score: number,\n        permalink: string,\n        replies: Comments | \"\" | undefined\n    },\n    kind: \"t1\"\n}\n\nexport interface Comments {\n  data: {\n    children: Comment[];\n  };\n  kind: \"Listing\";\n}\n\nexport function dateToText(utcTimestamp: number): string {\n  const now = Date.now();\n  const timeDifference = now - utcTimestamp;\n\n  const seconds = Math.floor(timeDifference / 1000);\n  if (seconds < 60) {\n    return seconds == 1 ? `${seconds} second ago` : `${seconds} seconds ago`;\n  }\n\n  const minutes = Math.floor(timeDifference / (1000 * 60));\n  if (minutes < 60) {\n    return minutes == 1 ? `${minutes} minute ago` : `${minutes} minutes ago`;\n  }\n\n  const hours = Math.floor(timeDifference / (1000 * 60 * 60));\n  if (hours < 24) {\n    return hours == 1 ? `${hours} hour ago` : `${hours} hours ago`;\n  }\n\n  const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));\n  if (days < 30) {\n    return days == 1 ? `${days} day ago` : `${days} days ago`;\n  }\n\n  const months = Math.floor(timeDifference / (1000 * 60 * 60 * 24 * 30));\n  if (months < 12) {\n    return months == 1 ? `${months} months ago` : `${months} months ago`;\n  }\n\n  const years = Math.floor(timeDifference / (1000 * 60 * 60 * 24 * 365));\n  return years == 1 ? `${years} years ago` : `${years} years ago`;\n}\n\nexport async function queryReddit(after: string | null = null): Promise<Posts> {\n  const hash = \"/r/\" + getSubreddit() + \"/.json\" + (after ? \"?after=\" + after : \"\");\n  const url = \"https://www.reddit.com\" + (!hash.startsWith(\"/\") ? \"/\" : \"\") + hash;\n  const response = await fetch(url);\n  return (await response.json()) as Posts;\n}\n\nexport async function getComments(post: Post) {\n  const response = await fetch(\"https://www.reddit.com/\" + post.data.permalink + \"/.json\");\n  const data = await response.json();\n  if (data.length < 2) return null;\n  return data[1] as Comments;\n}\n\nexport function getSubreddit() {\n  const hash = window.location.hash;\n  if (hash.length == 0) {\n    return \"all\";\n  }\n  return hash.substring(1, hash.indexOf(\"/\") > 0 ? hash.indexOf(\"/\") : hash.length);\n}\n\nexport function onVisibleOnce(target: HTMLElement, callback: () => void) {\n  let isTargetVisible = false;\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      if (entry.target === target && entry.isIntersecting) {\n        if (!isTargetVisible) {\n          isTargetVisible = true;\n          callback();\n        }\n        observer.unobserve(target);\n      }\n    });\n  });\n  observer.observe(target);\n}\n\nexport function htmlDecode(input) {\n  var doc = new DOMParser().parseFromString(input, \"text/html\");\n  return doc.documentElement.textContent;\n}\n\nexport function scrollToElement(targetElement: Element, container: Element) {\n    const elementOffset = targetElement.getBoundingClientRect().top;\n    const containerOffset = container.getBoundingClientRect().top;\n\n    // Scroll to the element with an additional 2em offset, accounting for the parent container's scroll position\n    container.scrollTop = elementOffset - containerOffset + container.scrollTop;\n  }", "import { Post, Comment, Posts, dateToText, getComments, getSubreddit, htmlDecode, onVisibleOnce, queryReddit, scrollToElement } from \"./utils\";\n\nfunction renderHeader() {\n  const header = document.querySelector(\"#header\")!;\n  header.querySelector(\"#header-subreddit\")!.innerHTML = \"/r/\" + getSubreddit();\n}\n\nfunction renderPosts(listing: Posts) {\n  const posts = document.querySelector(\"#posts\")! as HTMLElement;\n\n  for (let i = 0; i < listing.data.children.length; i++) {\n    const post = listing.data.children[i];\n    const postDiv = renderPost(post);\n    posts.append(postDiv);\n  }\n\n  const loadingDiv = showLoading();\n  onVisibleOnce(loadingDiv, async () => {\n    try {\n      const result = await queryReddit(listing.data.after);\n      renderPosts(result);\n    } catch (e) {\n      alert(JSON.stringify(e, null, 2));\n    } finally {\n      hideLoading();\n    }\n  });\n}\n\nconst missingThumbnailTags = new Set<String>([\"self\", \"nsfw\", \"default\", \"image\", \"spoiler\"]);\nfunction renderMedia(post: Post) {\n  if (post.data.is_self) {\n    return `<div class=\"post-self-preview\">${htmlDecode(post.data.selftext_html)}</div>`;\n  }\n\n  if (post.data.secure_media_embed && post.data.secure_media_embed.media_domain_url) {\n    const embed = post.data.secure_media_embed;\n    const postsWidth = document.querySelector(\"#posts\")!.clientWidth;\n    const embedWidth = postsWidth;\n    const embedHeight = Math.floor((embed.height / embed.width) * postsWidth);\n    if (embed.content.includes(\"iframe\")) {\n      const embedUrl = htmlDecode(embed.content\n        .replace(`width=\"${embed.width}\"`, `width=\"${embedWidth}\"`)\n        .replace(`height=\"${embed.height}\"`, `height=\"${embedHeight}\"`)\n        .replace(\"position:absolute;\", \"\"));\n      return `<div class=\"post-media\" style=\"width: ${embedWidth}px; height: ${embedHeight}px;\">${embedUrl}</div>`;\n    } else {\n      return `<div class=\"post-media\" style=\"width: ${embedWidth}px; height: ${embedHeight}px;\"><iframe width=\"${embedWidth}\" height=\"${embedHeight}\" src=\"${embed.media_domain_url}\"></iframe></div>`;\n    }\n  }\n\n  if (post.data.url.endsWith(\".gif\")) {\n    return `<div class=\"post-media\"><img src=\"${post.data.url}\"></img></div>`;\n  }\n\n  if (post.data.preview && post.data.preview.images && post.data.preview.images.length > 0) {\n    const postsWidth = document.querySelector(\"#posts\")!.clientWidth;\n    let image: { url: string; width: number; height: number } | null = null;\n    let bestWidth = 10000000;\n    for (const img of post.data.preview.images[0].resolutions) {\n      if (!image) {\n        image = img;\n        bestWidth = Math.abs(postsWidth - image.width);\n      } else {\n        const width = Math.abs(postsWidth - img.width);\n        if (width < bestWidth) {\n          image = img;\n          bestWidth = width;\n        }\n      }\n    }\n    if (!image) return \"\";\n    if (!post.data.preview.reddit_video_preview?.fallback_url) return `<div class=\"post-media\"><img src=\"${image.url}\"></img></div>`;\n    return `<div class=\"post-media\"><video src=\"${post.data.preview.reddit_video_preview.fallback_url}\" controls loop></img></div>`;\n  }\n\n  if (post.data.thumbnail && !missingThumbnailTags.has(post.data.thumbnail)) {\n    return `<div class=\"post-media\"><img src=\"${post.data.thumbnail}\"></img></div>`;\n  }\n  return \"\";\n}\n\nasync function renderComments(post: Post, container: HTMLElement) {\n    const loadingDiv = document.createElement(\"div\");\n    loadingDiv.innerHTML = \"Loading comments\";\n    container.append(loadingDiv);\n\n    try {\n        const commentsData = await getComments(post);\n        if (!commentsData) return;\n        for (const comment of commentsData.data.children) {\n            renderComment(comment, 0, container);\n        }\n\n    } finally {\n        loadingDiv.remove();\n    }\n}\n\nfunction renderComment(comment: Comment, level: number, container: HTMLElement) {\n    if (comment.data.author == undefined) return;\n    const commentDiv = document.createElement(\"div\");\n    commentDiv.innerHTML = `\n        <div class=\"comment-meta\">\n            <span class=\"comment-author\"><a href=\"https://www.reddit.com/u/${comment.data.author}\">${comment.data.author}</a></span>\n            <span class=\"comment-data\">${dateToText(comment.data.created_utc * 1000)}</span>\n            <span class=\"comment-points\">${comment.data.score} pts</span>\n        </div>\n        <div class=\"comment-text\">\n            ${htmlDecode(comment.data.body_html)}\n        </div>\n        <div class=\"comment-reply\"><a href=\"https://www.reddit.com/${comment.data.permalink}\" target=\"_blank\">Reply</a></div>\n    `;\n    commentDiv.classList.add(\"comment\");\n    commentDiv.style.marginLeft = level * 0.5 + \"em\";\n    container.append(commentDiv);\n    if (comment.data.replies && (comment.data.replies as any) != \"\") {\n        for (const reply of comment.data.replies.data.children) {\n            renderComment(reply, level + 1, container);\n        }\n    }\n}\n\nfunction renderPost(post: Post) {\n  let entryDiv = document.createElement(\"div\");\n  entryDiv.classList.add(\"post\");\n  entryDiv.innerHTML = `\n        <div class=\"post-title\"><a href=\"${post.data.url}\" target=\"_blank\">${post.data.title}</a></div>\n        <div class=\"post-meta\">\n            <span class=\"post-points\">${post.data.score} pts</span>\n            <span class=\"post-date\">${dateToText(post.data.created_utc * 1000)}</span>\n            <span class=\"post-author\">by <a href=\"https://www.reddit.com/u/${post.data.author}\" target=\"_blank\">${post.data.author}</a></span>\n            <span class=\"post-author\">in <a href=\"https://www.reddit.com/r/${post.data.subreddit}\" target=\"_blank\">r/${\n    post.data.subreddit\n  }</a></span>\n        </div>\n        ${!post.data.is_self ? `<div class=\"post-url\"><a href=\"\">${new URL(post.data.url).host}</a></div>` : \"\"}\n        ${renderMedia(post)}\n        <div class=\"post-comments\"><a href=\"\">Comments (${post.data.num_comments})</a></div>\n        <div class=\"post-comments-full\"></div>\n    `;\n  const comments = entryDiv.querySelector(\".post-comments\")!;\n  let isLoading = false;\n  comments.addEventListener(\"click\", async (event) => {\n    event.preventDefault();\n    if (comments.classList.contains(\"sticky\")) {\n        isLoading = false;\n        comments.classList.remove(\"sticky\");\n        (entryDiv.querySelector(\".post-comments-full\")! as HTMLElement).innerHTML = \"\";\n        requestAnimationFrame(() => {\n            scrollToElement(comments, document.querySelector(\"#posts\") as Element);\n        });\n    } else {\n        if (isLoading) return;\n        isLoading = true;\n        if (entryDiv.querySelector(\".post-self-preview\")) {\n            (entryDiv.querySelector(\".post-self-preview\") as HTMLElement).style.maxHeight = \"100%\";\n        }\n        await renderComments(post, entryDiv.querySelector(\".post-comments-full\")! as HTMLElement);\n        comments.classList.add(\"sticky\");\n    }\n  });\n  return entryDiv;\n}\n\nfunction showLoading() {\n  const loadingDiv = document.createElement(\"div\");\n  loadingDiv.id = \"loading\";\n  loadingDiv.classList.add(\"post-loading\");\n  const subreddit = \"/r/\" + getSubreddit();\n  loadingDiv.innerText = `Loading ${subreddit}`;\n  const postsDiv = document.querySelector(\"#posts\");\n  postsDiv?.appendChild(loadingDiv);\n  return loadingDiv;\n}\n\nfunction hideLoading() {\n  document.querySelector(\"#loading\")?.remove();\n}\n\nasync function load() {\n  renderHeader();\n  showLoading();\n  let result = await queryReddit();\n  hideLoading();\n  renderPosts(result);\n}\n\nwindow.addEventListener(\"hashchange\", () => {\n    document.querySelector(\"#posts\")!.innerHTML = \"\";\n  load();\n});\n\nload();\n"],
  "mappings": "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",
  "names": []
}
